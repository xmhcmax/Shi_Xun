我的思路就是：
1.在内存中：
二进制数据进来之后，我用recognizing函数来把他转化成dataPiece结构体形式，当做memNode节点的数据部分放在headNode的行链表中
大致结构如下
    headNode            memNode        memNode
————————————————   ——————————————   ————————————
|   memNode*   |-->|  dataPiece |   |   NULL   |
|              |   |  memNode*  |-->|   NULL   |
————————————————   ——————————————   ————————————

2.在行列转换时：
因为dataPiece中的数据是以行数据呈现的，所以把headNode的每一个memNode节点中的dataPiece中的数据再拿出来，依次放到dataUnion中，
这是一个集合，装入三种数据的其中一种。dataUnion是dataAtom的数据部分，dataAtom是列链表的节点，其头部是包含了更多信息的三个dataList数组元素之一
大致结构如下
       dataList            dataAtom            dataAtom
    —————————————   ----------------------   ------------
   0| dataAtom* |-->|dataUnion、dataAtom*|-->|   NULL   |
    —————————————   ----------------------   ------------ 
   1| dataAtom* |-->|dataUnion、dataAtom*|-->|   NULL   |
    —————————————   ----------------------   ------------
   2| dataAtom* |-->|dataUnion、dataAtom*|-->|   NULL   |
    —————————————   ----------------------   ------------
其中一dataList是一个数组，分别指向不同数据的dataAtom，一个dataList元素所形成的链表，就代表了一种数据的列形式


3.在文件中：
文件和索引分开，文件的后缀名自为".db"，命名为如"1.1.db",第一个数字表示级数，第二个数字表示是该级的第几个文件
索引的后缀名字为".index"，命名对应其对应的数据文件名字
文件和索引都有分级，其中级数（数字1）越大，文件越大，时间序列越旧，文件号（数字2）越大，时间序列就越新

关于文件位置：我们固定一个数据文件的存放大目录，比如D:\\dataFile，然后再在其中创建文件1,2,3,4,5,6,7,8,9，这九级目录，
             不同的级别目录下存放该级别的数据文件

4.文件管理：
大致目标设想是：限制文件的数据大小，进行文件的迭代更新，优化查找，不同级别文件放在不同文件夹之中，方便进行同一级别的操作
迭代的思路是：每一级文件最多有10个，当函数为文件命名的时候0-9文件号都用掉的时候，就调用迭代函数，将所有同级文件的内容移动到下一级的一个文件中，
             依然按照列存，就是100个数据放一起，然后是下一种数据100个，等等
优化查找的设想是：将每一个文件的第一个时间戳和最后一个数据的时间戳放到一个文件timeStamp_index.txt中，以文本形式存储，方便查找程序查阅跳转

5.查找：
我这里设置了很多的文件和索引，当然还有一个用来放文件时间戳的文件timeStamp_index.txt
因为我有了文件分级嘛，所以查找起来感觉很麻烦，用一个timeStamp_index.txt应该可以缩减查找时间。
过程我的设想是：首先对应查找函数传来的时间戳范围来对应timestamp_index.txt中的时间，要查找的时间戳头大于某个文件的首时间戳，小于某文件的尾时间戳
               那么就可以确定下要查找的数据范围，以第一个文件为例，进入索引，找到时间戳这个数据的起始偏移量和要找的数据的起始偏移量，先读取时间
               戳对比，然后根据对应时间戳的偏移量计算出所需求的数据的偏移量（该数据起始偏移量+（对应时间戳偏移量-时间戳起始偏移量））。其他的文
               件就同一个思路。